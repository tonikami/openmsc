<!DOCTYPE html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Angular Material style sheet -->
    <link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/angular_material/1.1.0/angular-material.min.css">
    <link rel="stylesheet" href="/stylesheets/style.css">

    <link rel="stylesheet" href="https://slimseun.com/js/vendor/angular-gridster/angular-gridster.min.css">

</head>

<body ng-app="musicCollab" Â  ng-cloak>
    <div ng-controller="AppCtrl" ng-cloak layout-padding>

        <!-- Play Forward Rewind -->

        <md-grid-list md-cols-xs="2" md-cols-sm="2" md-cols-md="2" md-cols-gt-md="2" md-row-height-gt-md="50px" md-row-height="50px" md-gutter="12px" md-gutter-gt-sm="1px" style="margin-top: 50px; margin-bottom: 50px; margin-right: 30%; margin-left: 30%">
            <md-grid-tile class="white">
                <ng-md-icon icon="stop" style="fill: pink" ng-click="stopAudio()" size="100"></ng-md-icon>
            </md-grid-tile>

            <md-grid-tile class="white">
                <ng-md-icon icon="play_circle_outline" style="fill: pink" size="100" ng-if="paused || !isPlaying" ng-click="playFunction()"></ng-md-icon>
                <ng-md-icon icon="pause_circle_outline" style="fill: pink" size="100" ng-if="!paused && isPlaying" ng-click="pauseAudio()"></ng-md-icon>
            </md-grid-tile>

        </md-grid-list>



        <!-- Block Layers -->
        <div style="overflow-x:scroll; overflow-y: hidden">
            <div style="width: 10000px">
                <md-content layout="row" layout-align="center end" style="margin-left: 16px; margin-right: 16px">
                    <div layout="row" layout-align="center center" style="width: 100px; padding-top: 20px;  padding-right: 20px;">
                        <md-input-container >
                            <label>BPM</label>
                            <input ng-model="beatsPerMin.val" ng-change="updateBPM()">
                        </md-input-container>
                    </div>
                    <div gridster="gridsterOptsCurrentBlocks" style="background:darkred; padding: 0px;" class="md-block" flex="100">
                        <ul>
                            <li gridster-item="item" ng-repeat="item in topBlocks track by $index" ng-class="item.color">
                            </li>
                        </ul>
                    </div>
                </md-content>
                <md-content>
                    <md-list flex>
                        <md-list-item ng-repeat="layer in layers track by $index" layout="row" layout-align="center center" ng-click="null">
                            <div layout="column" layout-align="center center" style="width: 100px;">
                                <md-button ng-click="voteUp($index)" class="md-icon-button">
                                    <ng-md-icon icon="keyboard_arrow_up" ng-style="layer.votedUp && {'fill': 'pink'}"></ng-md-icon>
                                </md-button>
                                <md-button class="md-icon-button md-primary" aria-label="Settings">{{layer.votes}}</md-button>
                                <md-button ng-click="voteDown($index)" class="md-icon-button">
                                    <ng-md-icon icon="keyboard_arrow_down" ng-style="layer.votedUp != null && !layer.votedUp && {'fill': 'pink'}" style="margin-top: 4px;"></ng-md-icon>
                                </md-button>
                            </div>
                            <div gridster="gridsterOptsLayer" style="background:darkred" class="md-block" flex="100" style="">
                                <ul>
                                    <li gridster-item="note" ng-repeat="note in layer.notes track by $index" class="yellow">
                                    </li>
                                </ul>
                            </div>
                        </md-list-item>
                    </md-list>
                </md-content>


                <br>
                <md-content layout="row" layout-align="center center" ng-if="justAdded==true" style="margin-left: 16px; margin-right: 16px">
                    <div layout="column" layout-align="center center" style="width: 100px;">
                        <md-button ng-click="addBlock($event)" class="md-icon-button">
                            <ng-md-icon icon="add_circle_outline"></ng-md-icon>
                        </md-button>
                    </div>
                    <div gridster="gridsterOpts" style="background:darkred; padding: 0px" ng-if="justAdded==true" class="md-block" flex="100">
                        <ul>
                            <li gridster-item="note" ng-repeat="note in currentLayer.notes track by $index" ng-class="note.color" ng-click="showTabDialog($event, $index)">
                                <ng-md-icon icon="drag_handle"> </ng-md-icon>
                            </li>
                        </ul>
                    </div>
                </md-content>
            </div>
        </div>

        <!-- Add/Submit Button -->
        <ng-md-icon icon="add_circle_outline" style="fill: pink" size="100" layout="row" layout-align="center" ng-if="justAdded==false" ng-click="addLayer()"></ng-md-icon>
        <ng-md-icon icon="file_upload" style="fill: pink" size="100" layout="row" layout-align="center" ng-if="justAdded==true" ng-click="submitLayer()"></ng-md-icon>

    </div>


    <!-- Angular Material requires Angular.js Libraries -->
    <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.5/angular.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.5/angular-animate.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.5/angular-aria.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.5/angular-messages.min.js"></script>
    <script src="//ajax.googleapis.com/ajax/libs/angularjs/1.5.5/angular-resource.js"></script>


    <!-- Angular Material Library -->
    <script src="https://ajax.googleapis.com/ajax/libs/angular_material/1.1.0/angular-material.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/angular-material-icons/0.7.1/angular-material-icons.min.js"></script>
    <script src="/ngWebAudio/src/ngWebAudio.js"></script>
    <script src="/shared/SoundPlayer.js"></script>


    <!-- Grid Stuff -->
    <script src="https://slimseun.com/js/vendor/angular-gridster/angular-gridster.min.js"></script>

    <!-- Your application bootstrap  -->
    <script type="text/javascript">
        var musicCollab = angular.module('musicCollab', ['ngMaterial', 'ngMdIcons', 'ngResource', 'gridster', 'sound.player', 'ngWebAudio']);

        musicCollab.factory("Increment_Vote", function ($resource) {
            return $resource('/api/:layerid/vote/increment', {
                layerid: '@layerid'
            });
        });

        musicCollab.factory("Decrement_Vote", function ($resource) {
            return $resource('/api/:layerid/vote/decrement', {
                layerid: '@layerid'
            });
        });

        musicCollab.factory("Layers", function ($resource) {
            return $resource('/api/layers')
        });

        musicCollab.factory("Upload_Layer", function ($resource) {
            return $resource('/api/upload/layer')
        });
        musicCollab.controller('AppCtrl', function ($scope, $mdDialog, $q, $mdToast, Increment_Vote, Decrement_Vote, Layers, Upload_Layer, SoundPlayerService, WebAudio) {
            $scope.isPlaying = false;
            $scope.paused = false;
            $scope.editable = true;
            $scope.splitFactor = 700;
            $scope.bpm = 150;
            $scope.vol = 1;
            $scope.justAdded = false;
            $scope.layers = [];
            $scope.currentLayer = null;
            $scope.topBlocks = [];

            $scope.beatsPerMin = {
                val: $scope.bpm,
            }

            $scope.init = function () {
                Layers.query(function (response) {
                    for (var i = 0; i < response.length; i++) {
                        for (var j = 0; j < response[i].notes.length; j++) {
                            response[i].notes[j].sizeX = response[i].notes[j].duration;
                            response[i].notes[j].col = response[i].notes[j].start;
                            response[i].notes[j].row = 1;
                            response[i].notes[j].sizeY = 1;
                        }

                    }
                    $scope.layers = response;
                });

                for (var i = 0; i < $scope.splitFactor; i++) {
                    $scope.topBlocks.push({
                        color: "red"
                    });
                }
            }
            $scope.init();

            $scope.updateBPM = function () {
                $scope.bpm = $scope.beatsPerMin.val;
                SoundPlayerService.setBPM($scope.bpm);
            }

            $scope.playFunction = function () {
                console.log($scope.isPlaying);
                console.log($scope.paused);
                if (!$scope.isPlaying) {
                    $scope.playAudio();
                    $scope.isPlaying = true;
                } else {
                    $scope.resumeAudio();
                }
            }

            $scope.playAudio = function () {
                var totalNotes = [];
                for (var i = 0; i < $scope.layers.length; i++) {
                    totalNotes = totalNotes.concat($scope.layers[i].notes);
                }

                if ($scope.currentLayer) {
                    totalNotes = totalNotes.concat($scope.currentLayer.notes);
                }
                for (var i = 0; i < totalNotes.length; i++) {
                    totalNotes[i].x = totalNotes[i].col;
                    totalNotes[i].length = totalNotes[i].sizeX;
                }
                SoundPlayerService.play(totalNotes, $scope.splitFactor, $scope.bpm);
                SoundPlayerService.onCurrentBeatChanged(function (beatIndex) {
                    for (var i = 0; i < $scope.topBlocks.length; i++) {
                        if (i == beatIndex) {
                            $scope.topBlocks[i].color = "blue"
                        }
                    }

                    $scope.currentBeatIndex = beatIndex;
                    $scope.$apply();
                });


                SoundPlayerService.onStop(function () {
                    $scope.topBlocks = [];
                    for (var i = 0; i < $scope.splitFactor; i++) {
                        $scope.topBlocks.push({
                            color: "red"
                        });
                    }
                    $scope.$apply();
                });
            }

            $scope.pauseAudio = function () {
                $scope.paused = true;
                SoundPlayerService.pause();
            }

            $scope.resumeAudio = function () {
                $scope.paused = false;
                SoundPlayerService.resume();
            }

            $scope.stopAudio = function () {
                $scope.isPlaying = false;
                $scope.paused = false;
                SoundPlayerService.stop();
            }

            $scope.gridsterOpts = {
                minRows: 1, // the minimum height of the grid, in rows
                maxRows: 1,
                columns: $scope.splitFactor, // the width of the grid, in columns
                colWidth: 'auto', // can be an integer or 'auto'.  'auto' uses the pixel width of the element divided by 'columns'
                rowHeight: '50', // can be an integer or 'match'.  Match uses the colWidth, giving you square widgets.
                margins: [1, 1], // the pixel distance between each widget
                defaultSizeX: 1, // the default width of a gridster item, if not specifed
                defaultSizeY: 1, // the default height of a gridster item, if not specified
                mobileBreakPoint: 1, // if the screen is not wider that this, remove the grid layout and stack the items
                pushing: false,
                swapping: false,
                resizable: {
                    enabled: true,
                    start: function (event, uiWidget, $element) {}, // optional callback fired when resize is started,
                    resize: function (event, uiWidget, $element) {}, // optional callback fired when item is resized,
                    stop: function (event, uiWidget, $element) {
                            $scope.editable = false;
                        } // optional callback fired when item is finished resizing
                },
                draggable: {
                    enabled: true, // whether dragging items is supported
                    handle: '.ddd', // optional selector for resize handle
                    start: function (event, uiWidget, $element) {}, // optional callback fired when drag is started,
                    drag: function (event, uiWidget, $element) {}, // optional callback fired when item is moved,
                    stop: function (event, uiWidget, $element) {
                            $scope.editable = false;
                        } // optional callback fired when item is finished dragging
                }
            };

            $scope.gridsterOptsLayer = {
                minRows: 1, // the minimum height of the grid, in rows
                maxRows: 1,
                columns: $scope.splitFactor, // the width of the grid, in columns
                colWidth: 'auto', // can be an integer or 'auto'.  'auto' uses the pixel width of the element divided by 'columns'
                rowHeight: '50', // can be an integer or 'match'.  Match uses the colWidth, giving you square widgets.
                margins: [1, 1], // the pixel distance between each widget
                defaultSizeX: 1, // the default width of a gridster item, if not specifed
                defaultSizeY: 1, // the default height of a gridster item, if not specified
                mobileBreakPoint: 1, // if the screen is not wider that this, remove the grid layout and stack the items
                resizable: {
                    enabled: false,
                    start: function (event, uiWidget, $element) {}, // optional callback fired when resize is started,
                    resize: function (event, uiWidget, $element) {}, // optional callback fired when item is resized,
                    stop: function (event, uiWidget, $element) {
                            $scope.editable = false;
                        } // optional callback fired when item is finished resizing
                },
                draggable: {
                    enabled: false, // whether dragging items is supported
                    handle: '.ddd', // optional selector for resize handle
                    start: function (event, uiWidget, $element) {}, // optional callback fired when drag is started,
                    drag: function (event, uiWidget, $element) {}, // optional callback fired when item is moved,
                    stop: function (event, uiWidget, $element) {
                            $scope.editable = false;
                        } // optional callback fired when item is finished dragging
                }
            };

            $scope.gridsterOptsCurrentBlocks = {
                minRows: 1, // the minimum height of the grid, in rows
                maxRows: 1,
                columns: $scope.splitFactor, // the width of the grid, in columns
                colWidth: 'auto', // can be an integer or 'auto'.  'auto' uses the pixel width of the element divided by 'columns'
                rowHeight: '25', // can be an integer or 'match'.  Match uses the colWidth, giving you square widgets.
                margins: [1, 1], // the pixel distance between each widget
                defaultSizeX: 1, // the default width of a gridster item, if not specifed
                defaultSizeY: 1, // the default height of a gridster item, if not specified
                mobileBreakPoint: 1, // if the screen is not wider that this, remove the grid layout and stack the items
                resizable: {
                    enabled: false,
                    start: function (event, uiWidget, $element) {}, // optional callback fired when resize is started,
                    resize: function (event, uiWidget, $element) {}, // optional callback fired when item is resized,
                    stop: function (event, uiWidget, $element) {
                            $scope.editable = false;
                        } // optional callback fired when item is finished resizing
                },
                draggable: {
                    enabled: false, // whether dragging items is supported
                    handle: '.ddd', // optional selector for resize handle
                    start: function (event, uiWidget, $element) {}, // optional callback fired when drag is started,
                    drag: function (event, uiWidget, $element) {}, // optional callback fired when item is moved,
                    stop: function (event, uiWidget, $element) {
                            $scope.editable = false;
                        } // optional callback fired when item is finished dragging
                }
            };

            $scope.increaseSplitFactor = function () {
                if ($scope.splitFactor != 5) {
                    $scope.splitFactor++;
                    $scope.updateGrid();
                }
            }
            $scope.decreaseSplitFactor = function () {
                if ($scope.splitFactor != 1) {
                    $scope.splitFactor--;
                    $scope.updateGrid();
                }
            }

            $scope.addLayer = function () {
                $scope.currentLayer = {
                    notes: [],
                    votedUp: null,
                };

                $scope.justAdded = true;
            };

            $scope.submitLayer = function () {
                //$scope.layers.push($scope.currentLayer);
                $scope.justAdded = false;
                Upload_Layer.save({}, {
                    notes: $scope.currentLayer.notes,
                }).$promise.then(function () {
                    $mdToast.show(
                        $mdToast.simple()
                        .textContent("Succesfully Added")
                        .position("bottom")
                        .hideDelay(3000)
                    );
                    $scope.currentLayer = null;
                    $scope.init();
                });
            }


            $scope.voteUp = function (index) {
                if ($scope.layers[index].votedUp == null) {
                    $scope.layers[index].votes++;
                    Increment_Vote.get({
                        layerid: $scope.layers[index]._id
                    });
                    $scope.layers[index].votedUp = true;
                } else if (!$scope.layers[index].votedUp) {
                    $scope.layers[index].votes++;
                    $scope.layers[index].votes++;
                    Increment_Vote.get({
                        layerid: $scope.layers[index]._id
                    });
                    Increment_Vote.get({
                        layerid: $scope.layers[index]._id
                    });
                    $scope.layers[index].votedUp = true;
                } else if ($scope.layers[index].votedUp) {
                    $scope.layers[index].votes--;
                    $scope.layers[index].votedUp = null;
                    Decrement_Vote.get({
                        layerid: $scope.layers[index]._id
                    });
                }
            }

            $scope.voteDown = function (index) {
                if ($scope.layers[index].votedUp == null) {
                    $scope.layers[index].votes--;
                    Decrement_Vote.get({
                        layerid: $scope.layers[index]._id
                    });
                    $scope.layers[index].votedUp = false;
                } else if ($scope.layers[index].votedUp) {
                    $scope.layers[index].votes--;
                    $scope.layers[index].votes--;
                    Decrement_Vote.get({
                        layerid: $scope.layers[index]._id
                    });
                    Decrement_Vote.get({
                        layerid: $scope.layers[index]._id
                    });
                    $scope.layers[index].votedUp = false;
                } else if (!$scope.layers[index].votedUp) {
                    $scope.layers[index].votes++;
                    $scope.layers[index].votedUp = null;
                    Increment_Vote.get({
                        layerid: $scope.layers[index]._id
                    });
                }
            }

            $scope.addBlock = function (ev) {
                $scope.showTabDialog(ev, -1);
            }

            $scope.endPositionCurrLayer = function () {
                if ($scope.currentLayer.notes.length == 0) {
                    return 0;
                }
                var furthestStart = -1;
                var furthestStartIndex = -1;
                for (var i = 0; i < $scope.currentLayer.notes.length; i++) {
                    var currStart = $scope.currentLayer.notes[i].start;
                    if (currStart > furthestStart) {
                        furthestStart = currStart;
                        furthestStartIndex = i;
                    }
                }
                var start = $scope.currentLayer.notes[furthestStartIndex].start + $scope.currentLayer.notes[furthestStartIndex].duration;
                return start;
            }

            $scope.showTabDialog = function (ev, index) {
                if ($scope.editable) {
                    $mdDialog.show({
                            controller: editBlockController,
                            locals: {
                                currentLayer: $scope.currentLayer,
                                index: index
                            },
                            templateUrl: '/html/editBlock.html',
                            parent: angular.element(document.body),
                            targetEvent: ev,
                            clickOutsideToClose: false
                        })
                        .then(function (response) {
                            if (index != -1) {
                                $scope.currentLayer.notes[index].color = response.color;
                                $scope.currentLayer.notes[index].path = response.notesName;
                            } else {
                                notes = {
                                    sizeX: 1,
                                    path: response.notesName,
                                    color: response.color
                                };
                                $scope.currentLayer.notes.push(notes);
                            }
                        });
                } else {
                    $scope.editable = true;
                }
            }
        });




        <!-- Controller for edit block popup -->
        function editBlockController($scope, $mdDialog, currentLayer, index, WebAudio) {
            $scope.currentLayer = currentLayer;
            $scope.index = index;
            $scope.color;
            $scope.notesName;

            $scope.init = function () {
                if ($scope.index != -1) {
                    $scope.color = $scope.currentLayer.notes[$scope.index].color;
                    $scope.notesName = $scope.currentLayer.notes[$scope.index].path;
                }
            }
            $scope.init();


            $scope.select = function (color, notesName) {
                if (color != 'brown') {
                    $scope.color = color;
                    $scope.notesName = notesName;
                    $scope.getAudio(notesName).play();
                } else {
                    var customSound = document.getElementById('soundFile');
                    temp.addEventListener('change', function () {
                        console.log('done');
                    });
                }
            };

            $scope.cancel = function () {
                $mdDialog.cancel();
            };

            $scope.save = function () {
                var audio = $scope.getAudio($scope.notesName);
                if ($scope.color) {
                    $mdDialog.hide({
                        color: $scope.color,
                        notesName: $scope.notesName
                    });
                }
            };

            $scope.getAudio = function (notesName) {
                var sound;
                if ($scope.notesName == 'c.wav') {
                    sound = WebAudio('sound/c.wav');
                } else if ($scope.notesName == 'cs.wav') {
                    sound = WebAudio('sound/cs.wav');
                } else if ($scope.notesName == 'd.wav') {
                    sound = WebAudio('sound/d.wav');
                } else if ($scope.notesName == 'eb.wav') {
                    sound = WebAudio('sound/eb.wav');
                } else if ($scope.notesName == 'e.wav') {
                    sound = WebAudio('sound/e.wav');
                } else if ($scope.notesName == 'f.wav') {
                    sound = WebAudio('sound/f.wav');
                } else if ($scope.notesName == 'fs.wav') {
                    sound = WebAudio('sound/fs.wav');
                } else if ($scope.notesName == 'g.wav') {
                    sound = WebAudio('sound/g.wav');
                } else if ($scope.notesName == 'gs.wav') {
                    sound = WebAudio('sound/gs.wav');
                } else if ($scope.notesName == 'a.wav') {
                    sound = WebAudio('sound/a.wav');
                } else if ($scope.notesName == 'bb.wav') {
                    sound = WebAudio('sound/bb.wav');
                } else if ($scope.notesName == 'b.wav') {
                    sound = WebAudio('sound/b.wav');
                }
                return sound;
            }
        };
    </script>

</body>

</html>